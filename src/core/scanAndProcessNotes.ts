// src/core/scanAndProcessNotes.ts
import { glob } from "glob";
import fs from "fs";
import path from "path";
import type {
  ScanOptions,
  ScanResult,
  ProcessedNode,
  SEOData,
  LLMConfigOptions,
} from "./types";
import { filenameToSlug } from "./utils/slugify"; // Slug utility.
import { markdownToSEO, LLMConfig as InternalLLMConfig } from "../llm/mdToSEO"; // SEO generation logic from the llm module.

/**
 * @file This module contains the core logic for scanning and processing Markdown notes.
 * It discovers Markdown files within a specified directory, extracts metadata such as title and path,
 * generates URL-friendly slugs, and can optionally enrich nodes with SEO data (title, description)
 * generated by an LLM for English content.
 */

// Module-level cache variables.
// These are used to store the results of the last scan in a production environment
// to avoid re-processing on subsequent calls if `options.forceScan` is false.
// Note: This is a simple in-memory cache. For more complex needs,
// consider a more advanced caching strategy or allowing cache adapter injection.
let allProcessedNotesStore: ProcessedNode[] | null = null;
let notesMapByFullPathSlugStore: Map<string, ProcessedNode> | null = null;
let notesMapBySimpleSlugStore: Map<string, Set<string>> | null = null;

/**
 * Scans a directory for Markdown files, processes each to extract metadata,
 * and optionally generates SEO data using an LLM.
 *
 * In production environments (when `process.env.NODE_ENV === 'production'`),
 * results are cached in memory to optimize subsequent calls. This behavior
 * can be overridden by setting `options.forceScan` to `true`.
 *
 * @async
 * @param {ScanOptions} options - Configuration for the scanning and processing operations.
 * @returns {Promise<ScanResult>} A promise that resolves to an object containing
 * the processed notes in various structured formats (an array and two maps for quick lookups).
 * Errors during individual file processing (reading, SEO generation) are logged to the console,
 * and processing continues for other files. Critical errors during setup (e.g., invalid contentPath)
 * may lead to promise rejection.
 *
 * @example
 * ```typescript
 * import { scanAndProcessNotes } from './scanAndProcessNotes'; // Adjust path based on your project structure
 * import path from 'path';
 *
 * async function processMyMarkdown() {
 * const options: ScanOptions = {
 * contentPath: path.join(process.cwd(), 'path/to/your/markdown/files'),
 * generateSeo: true,
 * llmConfig: {
 * minContentLengthForSeo: 50, // words
 * maxContentLengthForPrompt: 250, // words
 * },
 * includeFileContent: false,
 * forceScan: process.env.NODE_ENV !== 'production', // Example: force scan in dev
 * };
 *
 * try {
 * const result = await scanAndProcessNotes(options);
 * console.log(`Successfully processed ${result.allNotes.length} notes.`);
 * // result.allNotes, result.notesMapByFullPathSlug, result.notesMapBySimpleSlug can be used here.
 * } catch (error) {
 * console.error("An error occurred during note processing:", error);
 * }
 * }
 *
 * processMyMarkdown();
 * ```
 */
export async function scanAndProcessNotes(
  options: ScanOptions
): Promise<ScanResult> {
  const {
    contentPath,
    ignorePatterns,
    generateSeo = false,
    llmConfig: userLlmConfig,
    includeFileContent = false,
    forceScan = false,
  } = options;

  // In-memory caching check for production environment.
  if (
    notesMapByFullPathSlugStore &&
    process.env.NODE_ENV === "production" &&
    !forceScan
  ) {
    // console.info("[MarkBoost-SEO] Returning cached notes data."); // Optional: for debugging cache hits
    return {
      allNotes: allProcessedNotesStore!,
      notesMapByFullPathSlug: notesMapByFullPathSlugStore!,
      notesMapBySimpleSlug: notesMapBySimpleSlugStore!,
    };
  }

  // Ensure contentPath is an absolute path for reliable operations.
  const contentDir = path.resolve(contentPath);

  // Define default ignore patterns if none are provided by the user.
  // These are common directories/files to exclude from scanning.
  const effectiveIgnorePatterns = ignorePatterns || [
    "node_modules/**",
    "**/.*", // Typically hidden files/directories
    "dist/**", // Common build output folder
    ".git/**", // Git version control folder
  ];

  // Asynchronously find all .md files, respecting ignore patterns.
  // `posix: true` ensures forward slashes in paths for cross-platform consistency.
  const files = await glob("**/*.md", {
    cwd: contentDir,
    ignore: effectiveIgnorePatterns,
    nodir: true,
    posix: true,
  });

  const processedNotesList: ProcessedNode[] = [];
  const newNotesMapByFullPathSlug = new Map<string, ProcessedNode>();
  const newNotesMapBySimpleSlug = new Map<string, Set<string>>();

  // Prepare the LLM configuration that will be passed to the SEO generation function.
  // Defaults for individual LLM parameters (like modelName) are handled within `markdownToSEO`.
  const internalLlmConfig: InternalLLMConfig = {
    modelName: userLlmConfig?.modelName,
    minContentLengthForSeo: userLlmConfig?.minContentLengthForSeo,
    maxContentLengthForPrompt: userLlmConfig?.maxContentLengthForPrompt,
  };

  for (const relativeFilePath of files) {
    const absoluteFilePath = path.join(contentDir, relativeFilePath);
    // Extract the title from the filename by removing the .md extension.
    const title = path.basename(relativeFilePath, ".md");

    // The filePath stored in ProcessedNode is relative to the scanned contentDir.
    const filePath = relativeFilePath;

    // Generate web-friendly slugs for the full path and the simple title.
    const fullPathSlug = filenameToSlug(filePath.replace(/\.md$/, ""));
    const simpleSlug = filenameToSlug(title);

    let seoData: SEOData | undefined = undefined;
    let fileContent: string | undefined = undefined;

    // Read file content if SEO generation is enabled or if content inclusion is requested.
    if (generateSeo || includeFileContent) {
      try {
        fileContent = fs.readFileSync(absoluteFilePath, "utf-8");
      } catch (e: any) {
        console.error(
          `[MarkBoost-SEO] Failed to read file "${filePath}": ${e.message}`
        );
        // Continue to next file or process without content if appropriate.
        // Current logic proceeds, SEO generation might be skipped if fileContent is null.
      }
    }

    // If SEO generation is enabled and file content was successfully read, attempt to generate SEO data.
    if (generateSeo && fileContent) {
      try {
        // The markdownToSEO function internally checks for language and content length.
        seoData = await markdownToSEO(title, fileContent, internalLlmConfig);
      } catch (e: any) {
        console.error(
          `[MarkBoost-SEO] Failed to generate SEO for "${filePath}": ${e.message}`
        );
        // seoData will remain undefined, and the node will be created without it.
      }
    }

    // Create the ProcessedNode object with all extracted and generated data.
    const noteData: ProcessedNode = {
      id: fullPathSlug, // Using fullPathSlug as the unique identifier.
      title,
      filePath,
      fullPathSlug,
      simpleSlug,
      seo: seoData,
      content: includeFileContent ? fileContent : undefined,
      // Placeholder for future extensions:
      // frontmatter: undefined,
      // lastModified: undefined,
    };

    processedNotesList.push(noteData);
    newNotesMapByFullPathSlug.set(fullPathSlug, noteData);

    // Handle mapping of simple slugs to full path slugs for disambiguation.
    if (!newNotesMapBySimpleSlug.has(simpleSlug)) {
      newNotesMapBySimpleSlug.set(simpleSlug, new Set());
    }
    newNotesMapBySimpleSlug.get(simpleSlug)!.add(fullPathSlug);
  }

  // Update the module-level cache with the results from the current scan.
  allProcessedNotesStore = processedNotesList;
  notesMapByFullPathSlugStore = newNotesMapByFullPathSlug;
  notesMapBySimpleSlugStore = newNotesMapBySimpleSlug;

  return {
    allNotes: allProcessedNotesStore,
    notesMapByFullPathSlug: notesMapByFullPathSlugStore,
    notesMapBySimpleSlug: notesMapBySimpleSlugStore,
  };
}
